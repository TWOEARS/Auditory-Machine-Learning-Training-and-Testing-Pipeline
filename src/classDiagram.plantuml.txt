class TwoEarsIdTrainPipe{
  Flist trainset
  Flist testset
  init( sceneCfgs, hrir )
  setupData()
}
note left: top-level user interface,\nwrapping pipeline objects\npredefined for Two!Ears context
TwoEarsIdTrainPipe o-- "pipeline (1)" core.IdentificationTrainingPipeline
TwoEarsIdTrainPipe ..> dataProcs.MultiSceneCfgsIdProcWrapper: sets scene configuration(s)


class core.IdentificationTrainingPipeline{
  addModelCreator( trainer )
  addDataPipeProc( idProc )
  addGatherFeaturesProc( gatherFeaturesProc )
  setTrainData( trainData )
  setTestData( testData )
  run( modelNames )
}
note left: central pipeline class, controlling execution
core.IdentificationTrainingPipeline o-- "data (1)" core.IdentTrainPipeData
core.IdentificationTrainingPipeline *-- "dataPipeProcs (*)" core.DataPipeProc: runs cascade
core.IdentificationTrainingPipeline o-- "trainer (1)" modelTrainers.Base: runs


class core.DataPipeProc{
  connectToOutputFrom( outputtingProc )
  checkDataFiles()
  run()
}
note left: processes list of files
core.DataPipeProc o-- "dataFileProcessor (1)" core.IdProcInterface: executes for each file
core.DataPipeProc o-- core.IdentTrainPipeData


class core.IdCacheDirectory{
  setCacheTopDir( topDir )
  getCacheFilepath( cfg, createIfnExist )
  loadCacheDirectory()
  saveCacheDirectory()
}
core.IdCacheDirectory *-- "treeRoot (1)" core.IdCacheTreeElem


class core.IdCacheTreeElem{
  cfg
  path
  getCfg( cfgList, createIfMissing )
  integrateOtherTreeNode( otherNode )
}
core.IdCacheTreeElem *-- "cfgSubs (*)" core.IdCacheTreeElem


class core.IdentTrainPipeData{
  classNames
  data
  subsref()
  subsasgn()
  splitInPermutedStratifiedFolds( nFolds )
  saveDataFList( flistName, baseDir )
  loadWavFileList( wavflist )
  {static} combineData( varargin )
}
core.IdentTrainPipeData *-- "files (*)" core.IdentTrainPipeDataElem: in "data" array


class core.IdentTrainPipeDataElem{
  wavFileName
  x
  y
  mc
}


abstract class core.IdProcInterface{
  hasFileAlreadyBeenProcessed( wavFilepath )
  getOutputFilepath( wavFilepath )
  loadProcessedData( wavFilepath )
  loadInputData( wavFilepath )
  processSaveAndGetOutput( wavFilepath )
  saveOutput( wavFilepath )
  getOutputDependencies()
  ..
  {abstract} process( wavFilepath )
  {abstract} getInternOutputDependencies()
  {abstract} getOutput()
}
note left: processes individual files
core.IdProcInterface o-- "inputProc (1)" core.IdProcInterface
core.IdProcInterface *-- "cacheDirectory (1)" core.IdCacheDirectory


core.IdProcInterface <|-- dataProcs.AuditoryFEmodule
class dataProcs.AuditoryFEmodule{
  managerObject
  dataObject
  afeParams
  process( wavFilepath)
}
note left: output: AFE features


core.IdProcInterface <|-- dataProcs.GatherFeaturesProc
class dataProcs.GatherFeaturesProc{
  sceneCfgDataUseRatio
  prioClass
  process( wavFilepath)
}
dataProcs.GatherFeaturesProc ..> core.IdentTrainPipeData: loads feature vectors and labels


core.IdProcInterface <|-- dataProcs.IdProcWrapper
class dataProcs.IdProcWrapper{
  process( wavFilepath)
}
note left: decorates another IdProcInterface\nwith additional functionality
dataProcs.IdProcWrapper o-- "wrappedProcs (*)" core.IdProcInterface


core.IdProcInterface <|-- dataProcs.IdSimConvRoomWrapper
class dataProcs.IdSimConvRoomWrapper{
  convRoomSim
  reverberationMaxOrder
  IRDataset
  getDataFs()
  process( wavFilepath)
}
note left: executes binaural simulation,\noutput: earsignals, event on-/offset times
dataProcs.IdSimConvRoomWrapper o-- "sceneConfigs (1)" sceneConfig.SceneConfiguration


dataProcs.IdProcWrapper <|-- dataProcs.MultiSceneCfgsIdProcWrapper
class dataProcs.MultiSceneCfgsIdProcWrapper{
  hasFileAlreadyBeenProcessed( wavFilepath )
  processSaveAndGetOutput( wavFilepath )
  process( wavFilepath)
}
note left: executes wrapped IdProcInterface\nfor each scene configuration separately.\nOutput: nil
dataProcs.MultiSceneCfgsIdProcWrapper o-- "sceneProc (1)" dataProcs.SceneEarSignalProc
dataProcs.MultiSceneCfgsIdProcWrapper o-- "sceneConfigs (*)" sceneConfig.SceneConfiguration


dataProcs.IdProcWrapper <|-- dataProcs.ParallelRequestsAFEmodule
class dataProcs.ParallelRequestsAFEmodule{
  fs
  afeRequests
  process( wavFilepath)
}
note left: intelligently splits and combines\nAFE requests, caches them individually.\nOutput: cache file pathes of individual requests
dataProcs.ParallelRequestsAFEmodule *-- "individualAfeProcs (*)" dataProcs.AuditoryFEmodule


dataProcs.IdProcWrapper <|-- dataProcs.SceneEarSignalProc
class dataProcs.SceneEarSignalProc{
  getDatafs()
  process( wavFilepath)
  {static} adjustSNR( fs, signal1, sig1OnOffs, signal2, snrdB )
  {static} runningEnergy( fs, signal, blockSec, stepSec )
  {static} detectActivity( fs, signal, thresdB, hSec, blockSec, stepSec )
}
note left: "scripts" IdSimConvRoomWrapper,\nmixes scenes (several sources).\nOutput: earsignals, event on-/offset times
dataProcs.SceneEarSignalProc o-- "sceneConfig (1)" sceneConfig.SceneConfiguration
dataProcs.SceneEarSignalProc o-- "binauralSim (1)" dataProcs.IdSimConvRoomWrapper


core.IdProcInterface <|-- featureCreators.Base
abstract class featureCreators.Base{
  shiftSize_s
  minBlockToEventRatio
  blockSize_s
  labelBlockSize_s
  description
  setAfeData( afeData )
  process( wavFilepath )
  dummyProcess()
  cutDataBlock( afeData, backOffset_s )
  blockifyAndLabel( afeData, onOffs_s, annotsOut )
  ..
  {abstract} getAFErequests()
  {abstract} getFeatureInternOutputDependencies()
  {abstract} constructVector()
}
note left: cuts "streams" (wavs) into\nblocks, labels them, and\nconstructs feature vectors.\nOutput: x, y


featureCreators.Base <|-- featureCreators.FeatureSet1Blockmean
class featureCreators.FeatureSet1Blockmean{
  getAFErequests()
  constructVector()
  getFeatureInternOutputDependencies()
}
note left: constructs moments over time of\nams, ratemap, spectral\nfeatures and onset maps


abstract class models.Base{
  featureMask
  applyModel( x )
  verbose( newV )
  ..
  {abstract} applyModelMasked( x )
  ..
  {static} getPerformance( model, testSet, positiveClass, perfMeasure, maxDataSize, balMaxData )
}
models.Base ..> performanceMeasures.Base: produces

models.Base <|-- models.DataScalingModel
abstract class models.DataScalingModel{
  dataTranslators
  dataScalors
  scale2zeroMeanUnitVar( x, saveScalingFactors )
  ..
  {abstract} applyModelToScaledData( x )
}


models.DataScalingModel <|-- models.GlmNetModel
class models.GlmNetModel{
  setLambda( newLambda )
  getCoefImpacts( lambda )
  getBestLambdaCVresults()
  getBestMinStdCVresults()
  getHighestLambdaWithinStdCVresults()
  getLambdasAndNCoefs()
}


models.Base <|-- models.HPSmodel
class models.HPSmodel{
  hpsSet
  applyModelMasked( x )
}
note left: wrapper model to also\nsave hps sets
models.HPSmodel *-- "model (1) " models.Base



abstract class modelTrainers.Base{
  {static} balMaxData
  {static} featureMask
  maxDataSize
  setData( trainSet, testSet )
  setPositiveClass( modelName )
  setPerformanceMeasure( newPerformanceMeasure )
  getModel()
  verbose( newV )
  getPerformance()
  run()
  getPermutedTrainingData()
  ..
  {abstract} buildModel( x, y )
  {abstract} giveTrainedModel()
}
modelTrainers.Base ..> models.Base: produces


modelTrainers.Base <|-- modelTrainers.CVtrainer
class modelTrainers.CVtrainer{
  models
  setNumberOfFolds( nFolds )
  run()
  buildModel()
  getPerformance()
}
modelTrainers.CVtrainer o-- "trainer (1)" modelTrainers.Base


modelTrainers.Base <|-- modelTrainers.GlmNetLambdaSelectTrainer
class modelTrainers.GlmNetLambdaSelectTrainer{
  alpha
  family
  nLambda
  cvFolds
  run()
  buildModel()
}
modelTrainers.GlmNetLambdaSelectTrainer *-- "cvTrainer (1)" modelTrainers.CVtrainer
modelTrainers.GlmNetLambdaSelectTrainer *-- "coreTrainer (1)" modelTrainers.GlmNetTrainer


modelTrainers.Base <|-- modelTrainers.GlmNetTrainer
class modelTrainers.GlmNetTrainer{
  alpha
  family
  nLambda
  lambda
  buildModel( x, y )
}
modelTrainers.GlmNetTrainer ..> models.GlmNetModel: produces


modelTrainers.Base <|-- modelTrainers.HpsTrainer
abstract class modelTrainers.HpsTrainer{
  hpsSets
  hpsRefineStages
  hpsSearchBudget
  hpsCvFolds
  hpsMaxDataSize
  finalMaxDataSize
  run()
  ..
  {abstract} getHpsGridSearchSets()
  {abstract} refineGridTrainer( hps )
}
modelTrainers.HpsTrainer *-- "hpsCVtrainer (1)" modelTrainers.CVtrainer
modelTrainers.HpsTrainer *-- "coreTrainer (1)" modelTrainers.Base


modelTrainers.Base <|-- modelTrainers.LoadModelNoopTrainer
class modelTrainers.LoadModelNoopTrainer{
  modelPathBuilder
  modelParams
  buildModel( x, y )
  giveTrainedModel()
}


modelTrainers.HpsTrainer <|-- modelTrainers.SVMmodelSelectTrainer
class modelTrainers.SVMmodelSelectTrainer{
  hpsEpsilons
  hpsKernels
  hpsCrange
  hpsGammaRange
  makeProbModel
  getHpsGridSearchSets()
  refineGridTrainer( hps )
}
modelTrainers.SVMmodelSelectTrainer *.. modelTrainers.SVMtrainer
modelTrainers.HpsTrainer ..> models.HPSmodel: produces


modelTrainers.Base <|-- modelTrainers.SVMtrainer
class modelTrainers.SVMtrainer{
  epsilon
  kernel
  c
  gamma
  makeProbModel
  buildModel( x, y )
}


abstract class performanceMeasures.Base{
  performance
  datapointInfo
  Base( yTrue, yPred, datapointInfo )
  ..
  {abstract} calcPerformance( yTrue, yPred, dpiarg )
  {abstract} eqPm( other )
  {abstract} gtPm( other )
  {abstract} char()
  {abstract} double()
}


performanceMeasures.Base <|-- performanceMeasures.BAC2
class performanceMeasures.BAC2{
  tp
  fp
  tn
  fn
  sensitivity
  specificity
  acc
  BAC2( yTrue, yPred, datapointInfo )
  epPm( other ) 
  gtPm( other )
  double()
  char()
  calcPerformance( yTrue, yPred, dpi )
  makeDatapointInfoStats( fieldname, compiledPerfField )
}


class sceneConfig.ValGen{
  type
  val
  instantiate()
  value()
  isequal( other )
}


class sceneConfig.SourceBase{
  data
  offset
  instantiate()
  isequal( other )
}


class sceneConfig.SceneConfiguration{
  brirAzmIdx
  loop
  addSource( source, snr, loop )
  addRoom( room )
  setBRIRazm( azmIdx )
  instantiate()
  getSingleConfig( srcIdx )
  isequal( other )
}
sceneConfig.SceneConfiguration *-- "sources (*)" sceneConfig.SourceBase
sceneConfig.SceneConfiguration *-- "SNRs (*)" sceneConfig.ValGen
sceneConfig.SceneConfiguration *-- "room (1)" sceneConfig.RoomValGen


sceneConfig.ValGen <|-- sceneConfig.RoomValGen
class sceneConfig.RoomValGen{
  RoomValGen( val )
  value()
}


sceneConfig.SourceBase <|-- sceneConfig.PointSource
class sceneConfig.PointSource{
  instantiate()
  isequal( other )
}
sceneConfig.PointSource *-- "azimuth (1)" sceneConfig.ValGen
sceneConfig.PointSource *-- "distance (1)" sceneConfig.ValGen


sceneConfig.ValGen <|-- sceneConfig.NoiseValGen
class sceneConfig.NoiseValGen{
  NoiseValGen( val )
  value()
}


sceneConfig.ValGen <|-- sceneConfig.FileListValGen
class sceneConfig.FileListValGen{
  FileListValGen( val )
  isequal( other )
}


sceneConfig.SourceBase <|-- sceneConfig.DiffuseSource
class sceneConfig.DiffuseSource{
  instantiate()
  isequal( other )
}


sceneConfig.SourceBase <|-- sceneConfig.BRIRsource
class sceneConfig.BRIRsource{
  brirFName
  speakerId
  isequal( other )
}


